diff --git a/app/measurement/camera.tsx b/app/measurement/camera.tsx
index 99568a6..6868956 100644
--- a/app/measurement/camera.tsx
+++ b/app/measurement/camera.tsx
@@ -1,15 +1,6 @@
-<<<<<<< HEAD
-import React, { useState, useEffect, useRef, useCallback } from 'react';
-import { View, Text, StyleSheet, TouchableOpacity, Dimensions, Alert } from 'react-native';
-import { Camera, useCameraDevice, useCameraPermission, useFrameProcessor } from 'react-native-vision-camera';
-import { runOnJS } from 'react-native-worklets';
-import Svg, { Circle, Line } from 'react-native-svg';
-import * as Haptics from 'expo-haptics';
-import { calculateROM, smoothAngle, isStablePosition } from '../../src/utils/angleCalculation';
-=======
 import React, { useState, useEffect } from 'react';
 import { View, Text, StyleSheet, TouchableOpacity, Dimensions, Alert } from 'react-native';
-import { CameraView, useCameraPermissions, CameraType, Camera } from 'expo-camera';
+import { CameraView, useCameraPermissions } from 'expo-camera';
 import { cameraWithTensors } from '@tensorflow/tfjs-react-native';
 import Svg, { Circle, Line, Path } from 'react-native-svg';
 import * as Haptics from 'expo-haptics';
@@ -17,103 +8,28 @@ import * as tf from '@tensorflow/tfjs';
 import * as poseDetection from '@tensorflow-models/pose-detection';
 import { initTensorFlow, detector, estimateJointAngle } from '../../src/utils/tfPoseEngine';
 import { calculateROM, smoothAngle, isStablePosition, calculatePelvicTilt } from '../../src/utils/angleCalculation';
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
 import { Colors } from '../../src/constants/colors';
 import { JOINT_CONFIGS } from '../../src/constants/joints';
 import { useSettingsStore } from '../../src/stores/userStore';
 
 const { width, height } = Dimensions.get('window');
 
-<<<<<<< HEAD
-/**
- * Kamera-Screen für die Gelenk-Winkelmessung.
- *
- * AKTUELLER STATUS: Simulationsmodus
- * - Die Pose-Erkennung nutzt aktuell simulierte Werte
- * - TODO: BlazePose/MoveNet über react-native-vision-camera Frame Processor Plugin integrieren
- * - Die gesamte Mess-Pipeline (Stabilität, Smoothing, Auto-Freeze) ist bereits produktionsreif
- */
-=======
 // CRITICAL: HOC must be defined outside the component to prevent unmounting on every re-render
 const TensorCamera = cameraWithTensors(CameraView);
 
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
 export default function CameraScreen({ route, navigation }: any) {
     const { jointKey } = route?.params || { jointKey: 'knee_right' };
     const jointConfig = JOINT_CONFIGS[jointKey] || JOINT_CONFIGS['knee_right'];
-<<<<<<< HEAD
     const activeMovement = jointConfig.movements[0];
     const { stabilityThreshold, stabilityFrames } = useSettingsStore();
 
-    // Vision Camera Hooks
-    const { hasPermission, requestPermission } = useCameraPermission();
-    const device = useCameraDevice('back');
-=======
-    const activeMovement = jointConfig.movements[0]; // z.B. Flexion
-    const { stabilityThreshold, stabilityFrames } = useSettingsStore();
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
+    // Camera permission (expo-camera)
+    const [permission, requestPermission] = useCameraPermissions();
 
     const [currentAngle, setCurrentAngle] = useState(0);
     const [isStable, setIsStable] = useState(false);
-<<<<<<< HEAD
-    const [measurementDone, setMeasurementDone] = useState(false);
-    const [isFrozen, setIsFrozen] = useState(false);
-    const [isAligned, setIsAligned] = useState(false);
-    const [validationError, setValidationError] = useState<string | null>(null);
-    const [frameCount, setFrameCount] = useState(0);
-
-    const angleBufferRef = useRef<number[]>([]);
-    const isFrozenRef = useRef(false);
-    const isAlignedRef = useRef(false);
-    const measurementDoneRef = useRef(false);
-
-    // Refs synchron halten mit State
-    useEffect(() => { isFrozenRef.current = isFrozen; }, [isFrozen]);
-    useEffect(() => { isAlignedRef.current = isAligned; }, [isAligned]);
-    useEffect(() => { measurementDoneRef.current = measurementDone; }, [measurementDone]);
-
-    // State-Update vom Worklet-Thread
-    const updateMeasurementState = useCallback((rawAngle: number) => {
-        if (isFrozenRef.current || measurementDoneRef.current) return;
-
-        // Alignment-Phase: Erster erkannter Frame aktiviert das Tracking
-        if (!isAlignedRef.current) {
-            setIsAligned(true);
-            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
-            return;
-        }
-
-        const romAngle = calculateROM(rawAngle, jointConfig.id, activeMovement.type);
-
-        // Buffer-Management
-        angleBufferRef.current.push(romAngle);
-        if (angleBufferRef.current.length > 20) {
-            angleBufferRef.current.shift();
-        }
-
-        const smoothed = smoothAngle(angleBufferRef.current, 5);
-        setCurrentAngle(Math.round(smoothed));
-        setFrameCount(prev => prev + 1);
-
-        // Stabilitätsprüfung
-        const currentlyStable = isStablePosition(angleBufferRef.current, stabilityThreshold, stabilityFrames);
-
-        setIsStable((prevStable) => {
-            if (!prevStable && currentlyStable) {
-                Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
-            }
-            return currentlyStable;
-        });
-    }, [jointConfig.id, activeMovement.type, stabilityThreshold, stabilityFrames]);
-
-    // Frame Processor (Worklet-Thread)
-    const frameProcessor = useFrameProcessor((frame) => {
-        'worklet';
-        // TODO: Hier BlazePose/MoveNet Frame Processor Plugin einsetzen
-        // Beispiel: const poses = detectPose(frame);
-        // const angle = calculateAngleFromKeypoints(poses[0], jointConfig.landmarkTriple);
-=======
 
+    // Ref-wrapped state to avoid stale closures in the camera stream callback
     const [measurementDone, _setMeasurementDone] = useState(false);
     const measurementRef = React.useRef(false);
     const setMeasurementDone = (val: boolean) => { measurementRef.current = val; _setMeasurementDone(val); };
@@ -129,7 +45,7 @@ export default function CameraScreen({ route, navigation }: any) {
     const [tfReady, setTfReady] = useState(false);
     const angleBufferRef = React.useRef<number[]>([]);
 
-    // --- Alignment & Validation Logic ---
+    // Alignment & Validation Logic
     const [isAligned, _setIsAligned] = useState(false);
     const alignedRef = React.useRef(false);
     const setIsAligned = (val: boolean) => { alignedRef.current = val; _setIsAligned(val); };
@@ -137,7 +53,7 @@ export default function CameraScreen({ route, navigation }: any) {
     const [validationError, setValidationError] = useState<string | null>(null);
     const initialJointCenterRef = React.useRef<{ x: number, y: number } | null>(null);
 
-    const [debugText, setDebugText] = useState(""); // DIAGNOSTIC STATE
+    const [debugText, setDebugText] = useState("");
 
     // Init ML Model
     useEffect(() => {
@@ -148,9 +64,15 @@ export default function CameraScreen({ route, navigation }: any) {
         setupTF();
     }, []);
 
-    // Simulate Alignment taking a few seconds
-    // We remove the auto-timeout and now rely on the actual pose detection
-    // to trigger the alignment state once the user is in frame.
+    // Auto-Freeze bei stabiler Position
+    useEffect(() => {
+        if (isStable && !isFrozen) {
+            const timer = setTimeout(() => {
+                triggerConfirmation();
+            }, 500);
+            return () => clearTimeout(timer);
+        }
+    }, [isStable, isFrozen]);
 
     // --- Real Tracking Logic ---
     const isProcessing = React.useRef(false);
@@ -158,15 +80,13 @@ export default function CameraScreen({ route, navigation }: any) {
     const handleCameraStream = (images: IterableIterator<tf.Tensor3D>, updateCameraContext: () => void, gl: any) => {
         const loop = async () => {
             if (measurementRef.current || !detector || frozenRef.current) {
-                // If frozen or done, just burn the frames without processing to keep the stream alive but static
+                // If frozen or done, just burn the frames to keep the stream alive
                 const tfImg = images.next().value;
                 if (tfImg) tf.dispose(tfImg);
-
                 requestAnimationFrame(loop);
                 return;
             }
 
-            // ALWAYS fetch the next tensor to prevent blocking the stream buffer!
             const imageTensor = images.next().value;
 
             if (!imageTensor) {
@@ -174,11 +94,7 @@ export default function CameraScreen({ route, navigation }: any) {
                 return;
             }
 
-            // We don't discard immediately if frozen, because we want the skeleton to
-            // keep rendering its last position on screen. We just skip updates later.
-
-            // If currently processing the previous frame, 
-            // dispose this frame immediately to keep the 60fps camera feed smooth.
+            // Skip if still processing previous frame
             if (isProcessing.current) {
                 tf.dispose(imageTensor);
                 requestAnimationFrame(loop);
@@ -215,27 +131,22 @@ export default function CameraScreen({ route, navigation }: any) {
 
                         if (rawAngle > 0) {
                             if (!alignedRef.current) {
-                                setIsAligned(true); // Updates ref too
+                                setIsAligned(true);
                                 if (!initialJointCenterRef.current) {
                                     initialJointCenterRef.current = { x: p2.x, y: p2.y };
                                 }
                                 setValidationError(null);
                                 Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
-                            } else if (initialJointCenterRef.current && !frozenRef.current) {
-                                // Freeze Check: Only update drift and angles if NOT frozen
-                                // If frozen, we just skip this block so the UI keeps displaying the last state 
-                                // and the frozen overlay remains active.
-
+                            } else if (!frozenRef.current) {
                                 // Drift validation
                                 const dx = initialJointCenterRef.current ? p2.x - initialJointCenterRef.current.x : 0;
                                 const dy = initialJointCenterRef.current ? p2.y - initialJointCenterRef.current.y : 0;
                                 const drift = Math.sqrt(dx * dx + dy * dy);
 
-                                setDebugText(`Scores: ${s1.toFixed(2)}, ${s2.toFixed(2)}, ${s3.toFixed(2)} | Raw A: ${rawAngle.toFixed(1)} | Drift: ${drift.toFixed(0)}`);
+                                setDebugText(`Scores: ${s1.toFixed(2)}, ${s2.toFixed(2)}, ${s3.toFixed(2)} | Raw: ${rawAngle.toFixed(1)} | Drift: ${drift.toFixed(0)}`);
 
-                                const DRIFT_TOLERANCE = 150; // Massively relaxed again just to be safe
+                                const DRIFT_TOLERANCE = 150;
 
-                                // Drift validation
                                 if (drift > DRIFT_TOLERANCE) {
                                     setValidationError("Gelenk aus dem Fokus gerutscht");
                                     setIsStable(false);
@@ -273,7 +184,7 @@ export default function CameraScreen({ route, navigation }: any) {
                                     const smoothed = smoothAngle(angleBufferRef.current, 5);
                                     setCurrentAngle(Math.round(smoothed));
 
-                                    // Is Stable? Only freeze if they aren't cheating
+                                    // Stability check (only if no evasion detected)
                                     const currentlyStable = !evasionError && isStablePosition(angleBufferRef.current, stabilityThreshold, stabilityFrames);
                                     setIsStable((prevStable) => {
                                         if (!prevStable && currentlyStable) {
@@ -301,27 +212,9 @@ export default function CameraScreen({ route, navigation }: any) {
         };
         loop();
     };
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
 
-        // SIMULATION: Realistischere Werte mit langsamer Drift statt Random-Sprüngen
-        const baseAngle = 90;
-        const noise = (Math.random() - 0.5) * 6; // +/- 3° Rauschen
-        const simulatedAngle = baseAngle + noise;
-
-        runOnJS(updateMeasurementState)(simulatedAngle);
-    }, [updateMeasurementState]);
-
-    // Auto-Freeze bei stabiler Position
-    useEffect(() => {
-        if (isStable && !isFrozen) {
-            const timer = setTimeout(() => {
-                triggerConfirmation();
-            }, 500);
-            return () => clearTimeout(timer);
-        }
-    }, [isStable, isFrozen]);
-
-    if (!hasPermission) {
+    // Permission check
+    if (!permission?.granted) {
         return (
             <View style={styles.container}>
                 <Text style={styles.text}>Wir benötigen Zugang zur Kamera.</Text>
@@ -332,23 +225,9 @@ export default function CameraScreen({ route, navigation }: any) {
         );
     }
 
-<<<<<<< HEAD
-    if (device == null) {
-        return (
-            <View style={styles.container}>
-                <Text style={styles.text}>Keine Kamera gefunden</Text>
-            </View>
-        );
-    }
-
     const triggerConfirmation = () => {
         setIsFrozen(true);
         setValidationError(null);
-=======
-    const triggerConfirmation = () => {
-        setIsFrozen(true);
-        setValidationError(null); // Clear any errors
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
         Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
     };
 
@@ -357,14 +236,8 @@ export default function CameraScreen({ route, navigation }: any) {
             setMeasurementDone(true);
             Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
 
-<<<<<<< HEAD
             const bodySide = jointKey.includes('left') ? 'left' : jointKey.includes('right') ? 'right' : 'left';
 
-=======
-            const bodySide = jointKey.includes('left') ? 'left' : jointKey.includes('right') ? 'right' : 'left'; // default to left if unknown
-
-            // Pass the actual recorded data to the result screen to save it
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
             navigation.replace('Result', {
                 angle: currentAngle,
                 jointType: jointConfig.id,
@@ -373,11 +246,7 @@ export default function CameraScreen({ route, navigation }: any) {
                 jointLabel: jointConfig.label
             });
         } catch (error: any) {
-<<<<<<< HEAD
-            Alert.alert("Navigationsfehler", error?.message);
-=======
             Alert.alert("Navigationsfehler", error?.message || "Konnte ResultScreen nicht laden.");
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
         }
     };
 
@@ -385,74 +254,42 @@ export default function CameraScreen({ route, navigation }: any) {
         setIsFrozen(false);
         setIsStable(false);
         angleBufferRef.current = [];
-<<<<<<< HEAD
-        setFrameCount(0);
-=======
-        initialJointCenterRef.current = null; // Reset the anchor point
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
+        initialJointCenterRef.current = null;
         Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
     };
 
     const getTrafficLightColor = () => {
-<<<<<<< HEAD
         if (!isAligned) return Colors.error[500];
         if (!isStable) return Colors.warning[500];
         return Colors.success[500];
-=======
-        if (!isAligned) return Colors.error?.[500] || '#E74C3C'; // Red
-        if (!isStable) return Colors.warning?.[500] || '#F39C12'; // Yellow
-        return Colors.success?.[500] || '#27AE60'; // Green
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
     };
 
     const renderGhostOverlay = () => {
         const color = getTrafficLightColor();
-<<<<<<< HEAD
         const sw = "6";
-=======
-        const strokeWidth = "6";
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
 
         if (jointKey.includes('knee') || jointKey.includes('hip') || jointKey.includes('ankle')) {
             return (
                 <Svg height={height} width={width} pointerEvents="none" style={StyleSheet.absoluteFill}>
-<<<<<<< HEAD
                     <Line x1={width / 2} y1={height * 0.3} x2={width / 2} y2={height * 0.6} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
                     <Line x1={width / 2} y1={height * 0.6} x2={width / 2} y2={height * 0.9} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
                     <Circle cx={width / 2} cy={height * 0.6} r="16" fill="transparent" stroke={color} strokeWidth="4" />
                 </Svg>
             );
-        } else {
-            return (
-                <Svg height={height} width={width} pointerEvents="none" style={StyleSheet.absoluteFill}>
-                    <Line x1={width / 2} y1={height * 0.3} x2={width / 2} y2={height * 0.5} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
-                    <Line x1={width * 0.7} y1={height * 0.5} x2={width / 2} y2={height * 0.5} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
-                    <Circle cx={width / 2} cy={height * 0.5} r="16" fill="transparent" stroke={color} strokeWidth="4" />
-                </Svg>
-            );
-        }
-=======
-                    {/* Ghost: Becken/Hüfte -> Knie -> Knöchel */}
-                    <Line x1={width / 2} y1={height * 0.3} x2={width / 2} y2={height * 0.6} stroke={color} strokeWidth={strokeWidth} strokeDasharray="10, 10" />
-                    <Line x1={width / 2} y1={height * 0.6} x2={width / 2} y2={height * 0.9} stroke={color} strokeWidth={strokeWidth} strokeDasharray="10, 10" />
-                    <Circle cx={width / 2} cy={height * 0.6} r="16" fill="transparent" stroke={color} strokeWidth="4" />
-                </Svg>
-            );
         } else if (jointKey.includes('shoulder') || jointKey.includes('elbow') || jointKey.includes('wrist')) {
             return (
                 <Svg height={height} width={width} pointerEvents="none" style={StyleSheet.absoluteFill}>
-                    {/* Ghost: Rumpf/Schulter -> Ellenbogen -> Hand/Unterarm */}
-                    <Line x1={width / 2} y1={height * 0.4} x2={width / 2} y2={height * 0.7} stroke={color} strokeWidth={strokeWidth} strokeDasharray="10, 10" />
-                    <Line x1={width / 2} y1={height * 0.4} x2={width * 0.2} y2={height * 0.4} stroke={color} strokeWidth={strokeWidth} strokeDasharray="10, 10" />
+                    <Line x1={width / 2} y1={height * 0.4} x2={width / 2} y2={height * 0.7} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
+                    <Line x1={width / 2} y1={height * 0.4} x2={width * 0.2} y2={height * 0.4} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
                     <Circle cx={width / 2} cy={height * 0.4} r="16" fill="transparent" stroke={color} strokeWidth="4" />
                 </Svg>
             );
         }
 
-        // Default (Arm/Leg Straight)
+        // Default fallback
         return (
             <Svg height={height} width={width} pointerEvents="none" style={StyleSheet.absoluteFill}>
-                <Line x1={width / 2} y1={height * 0.2} x2={width / 2} y2={height * 0.8} stroke={color} strokeWidth={strokeWidth} strokeDasharray="10, 10" />
+                <Line x1={width / 2} y1={height * 0.2} x2={width / 2} y2={height * 0.8} stroke={color} strokeWidth={sw} strokeDasharray="10, 10" />
                 <Circle cx={width / 2} cy={height * 0.5} r="16" fill="transparent" stroke={color} strokeWidth="4" />
             </Svg>
         );
@@ -466,32 +303,30 @@ export default function CameraScreen({ route, navigation }: any) {
         const p2 = activePose.keypoints[triple[1]];
         const p3 = activePose.keypoints[triple[2]];
 
-        const minScore = 0.2; // very low for debug visibility
+        const minScore = 0.2;
         const dynamicColor = getTrafficLightColor();
 
-        // TensorCamera output dimensions are scaled to the screen width/height.
-        // We set resizeWidth=144, resizeHeight=256 to match 16:9 vertical phone aspect ratio.
+        // TensorCamera output dimensions are scaled to the screen
         const TENSOR_WIDTH = 144;
         const TENSOR_HEIGHT = 256;
-
         const scaleX = width / TENSOR_WIDTH;
         const scaleY = height / TENSOR_HEIGHT;
 
         return (
             <Svg height={height} width={width} pointerEvents="none" style={StyleSheet.absoluteFill}>
-                {/* 1. Debug: Draw ALL points to see what the ML detects */}
+                {/* Debug: Draw ALL detected keypoints */}
                 {activePose.keypoints.map((k, i) => {
                     if ((k.score || 0) < minScore) return null;
                     return <Circle key={i} cx={k.x * scaleX} cy={k.y * scaleY} r="3" fill="rgba(255,255,255,0.4)" />
                 })}
 
-                {/* 2. Highlight the specific joint triple if confident enough */}
+                {/* Highlight the specific joint triple with protractor arc */}
                 {(p1 && p2 && p3 && ((p1.score || 0) > 0.1 && (p2.score || 0) > 0.1 && (p3.score || 0) > 0.1)) && (() => {
                     const x1 = p1.x * scaleX; const y1 = p1.y * scaleY;
                     let x2 = p2.x * scaleX; let y2 = p2.y * scaleY;
                     const x3 = p3.x * scaleX; const y3 = p3.y * scaleY;
 
-                    // LOCK the center joint to the initial position if aligned
+                    // Lock the center joint to initial position if aligned
                     if (alignedRef.current && initialJointCenterRef.current) {
                         x2 = initialJointCenterRef.current.x * scaleX;
                         y2 = initialJointCenterRef.current.y * scaleY;
@@ -548,27 +383,14 @@ export default function CameraScreen({ route, navigation }: any) {
                 })()}
             </Svg>
         );
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
     };
 
     return (
         <View style={styles.container}>
-<<<<<<< HEAD
-            <Camera
-                style={StyleSheet.absoluteFill}
-                device={device}
-                isActive={!isFrozen}
-                frameProcessor={frameProcessor}
-                pixelFormat="yuv"
-            />
-
-            {/* Ghost-Overlay für Positionierung */}
-=======
             {tfReady ? (
                 <TensorCamera
                     style={StyleSheet.absoluteFill}
                     facing="back"
-                    // TensorCamera Params
                     useCustomShadersToResize={false}
                     cameraTextureHeight={1920}
                     cameraTextureWidth={1080}
@@ -584,16 +406,19 @@ export default function CameraScreen({ route, navigation }: any) {
                 </View>
             )}
 
-            {/* Skalierbares Overlay (Ghost) */}
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
+            {/* Ghost Overlay for positioning guidance */}
             {!isAligned && (
                 <View style={[StyleSheet.absoluteFill, { pointerEvents: 'none', zIndex: 10 }]}>
                     {renderGhostOverlay()}
                 </View>
             )}
-<<<<<<< HEAD
 
-            {/* Winkelanzeige */}
+            {/* Live ML Skeleton overlay */}
+            <View style={[StyleSheet.absoluteFill, { pointerEvents: 'none', zIndex: 11 }]}>
+                {renderRealSkeleton()}
+            </View>
+
+            {/* Angle Display */}
             <View style={[styles.angleDisplay, { top: height * 0.42, left: 16, right: 16 }]}>
                 {isAligned ? (
                     <View style={styles.angleContainer}>
@@ -618,12 +443,12 @@ export default function CameraScreen({ route, navigation }: any) {
                 )}
             </View>
 
-            {/* Simulation Badge */}
-            <View style={styles.simBadge}>
-                <Text style={styles.simText}>DEMO-MODUS</Text>
+            {/* Debug Panel */}
+            <View style={styles.debugPanel}>
+                <Text style={styles.debugText}>{debugText}</Text>
             </View>
 
-            {/* Anleitungstext */}
+            {/* Instructions */}
             {!isFrozen && (
                 <View style={styles.instructionBanner}>
                     <Text style={styles.instructionTitle}>{jointConfig.label}</Text>
@@ -665,100 +490,17 @@ export default function CameraScreen({ route, navigation }: any) {
                         ) : (
                             <View style={styles.statusBox}>
                                 <Text style={[styles.statusText, isStable ? styles.statusSuccess : {}]}>
-                                    {isStable ? 'Stabile Position erkannt' : `Messung läuft... (${frameCount} Frames)`}
+                                    {isStable ? 'Stabile Position erkannt' : 'Messung läuft...'}
                                 </Text>
                             </View>
                         )}
 
-                        {/* Manueller Auslöser als Fallback */}
-                        {isAligned && !isStable && frameCount > 20 && (
+                        {/* Manual freeze button */}
+                        {isAligned && (
                             <TouchableOpacity style={styles.manualCaptureButton} onPress={triggerConfirmation}>
-                                <Text style={styles.manualCaptureText}>Manuell erfassen</Text>
+                                <Text style={styles.manualCaptureText}>Winkel einfrieren</Text>
                             </TouchableOpacity>
                         )}
-=======
-
-            {/* Live ML Skeleton (Immer anzeigen für Debugging) */}
-            <View style={[StyleSheet.absoluteFill, { pointerEvents: 'none', zIndex: 11 }]}>
-                {renderRealSkeleton()}
-            </View>
-
-            {/* Angle Display prominent next to the joint */}
-            <View style={[styles.angleDisplay, { top: height * 0.5 - 20, left: width * 0.5 + 40 }]}>
-                {isAligned ? (
-                    <Text style={[
-                        styles.angleText,
-                        {
-                            color: (currentAngle >= activeMovement.normalRange[0] && currentAngle <= activeMovement.normalRange[1])
-                                ? Colors.success[500]
-                                : Colors.warning[500],
-                            fontSize: 32 // smaller to fit target
-                        }
-                    ]}>
-                        {currentAngle}° / Ziel: {activeMovement.normalRange[1]}°
-                    </Text>
-                ) : (
-                    <Text style={[styles.angleText, { fontSize: 24, color: 'rgba(255,255,255,0.5)' }]}>
-                        {currentAngle}°
-                    </Text>
-                )}
-            </View>
-
-            {/* DEBUG PANEL */}
-            <View style={{ position: 'absolute', top: 50, left: 10, backgroundColor: 'rgba(0,0,0,0.5)', padding: 10, borderRadius: 5 }}>
-                <Text style={{ color: 'lime', fontSize: 12, fontFamily: 'monospace' }}>{debugText}</Text>
-            </View>
-
-            {/* Anleitungstext Oben */}
-            {!isFrozen && (
-                <View style={styles.instructionBanner}>
-                    {activeMovement.instructions.map((inst, idx) => (
-                        <Text key={idx} style={styles.instructionText}>
-                            • {inst}
-                        </Text>
-                    ))}
-                </View>
-            )}
-
-            {/* Footer Container */}
-            <View style={styles.footer}>
-                {isFrozen ? (
-                    <View style={styles.confirmationBox}>
-                        <Text style={styles.confirmationTitle}>{currentAngle}° erfasst</Text>
-                        <Text style={styles.confirmationSubtitle}>Möchtest du diesen Wert eintragen?</Text>
-                        <View style={styles.buttonRow}>
-                            <TouchableOpacity style={styles.retakeButton} onPress={retakeMeasurement}>
-                                <Text style={styles.retakeButtonText}>Wiederholen</Text>
-                            </TouchableOpacity>
-                            <TouchableOpacity style={styles.confirmButton} onPress={confirmAndSave}>
-                                <Text style={styles.confirmButtonText}>Eintragen</Text>
-                            </TouchableOpacity>
-                        </View>
-                    </View>
-                ) : (
-                    <>
-                        {/* Status Message Area */}
-                        {!isAligned ? (
-                            <View style={styles.statusBoxWarning}>
-                                <Text style={styles.statusTextWarning}>Bitte Gelenkmittelpunkt im Bild positionieren...</Text>
-                            </View>
-                        ) : validationError ? (
-                            <View style={styles.errorBox}>
-                                <Text style={styles.errorText}>{validationError}</Text>
-                            </View>
-                        ) : (
-                            <View style={styles.statusBox}>
-                                <Text style={[styles.statusText, isStable ? styles.statusSuccess : {}]}>
-                                    {isStable ? 'Stabile Position erkannt ✓' : 'Messung läuft...'}
-                                </Text>
-                            </View>
-                        )}
-
-                        {/* Always show Freeze Button so user can force a save test at 0 degrees */}
-                        <TouchableOpacity style={styles.saveButton} onPress={triggerConfirmation}>
-                            <Text style={styles.saveButtonText}>Winkel einfrieren</Text>
-                        </TouchableOpacity>
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
                     </>
                 )}
             </View>
@@ -780,10 +522,9 @@ const styles = StyleSheet.create({
     angleValue: { fontSize: 56, fontWeight: 'bold', textShadowColor: 'rgba(0,0,0,0.8)', textShadowOffset: { width: 1, height: 1 }, textShadowRadius: 10 },
     angleTarget: { fontSize: 16, color: 'rgba(255,255,255,0.7)', marginTop: 4 },
     angleLoading: { fontSize: 18, color: 'rgba(255,255,255,0.5)', textAlign: 'center' },
-    simBadge: { position: 'absolute', top: 16, right: 16, backgroundColor: 'rgba(231,76,60,0.8)', paddingHorizontal: 12, paddingVertical: 4, borderRadius: 8 },
-    simText: { color: 'white', fontSize: 11, fontWeight: 'bold', letterSpacing: 1 },
+    debugPanel: { position: 'absolute', top: 50, left: 10, backgroundColor: 'rgba(0,0,0,0.5)', padding: 10, borderRadius: 5 },
+    debugText: { color: 'lime', fontSize: 12 },
     footer: { position: 'absolute', bottom: 40, left: 16, right: 16, alignItems: 'center' },
-<<<<<<< HEAD
     statusBox: { backgroundColor: 'rgba(0,0,0,0.7)', paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 12 },
     statusBoxWarning: { backgroundColor: Colors.warning[500], paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 12 },
     errorBox: { backgroundColor: Colors.error[500], paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 12 },
@@ -793,19 +534,8 @@ const styles = StyleSheet.create({
     statusSuccess: { color: Colors.success[500] },
     saveButton: { backgroundColor: Colors.primary[500], paddingVertical: 18, paddingHorizontal: 48, borderRadius: 32, width: '100%', alignItems: 'center', marginTop: 20, marginHorizontal: 16 },
     saveButtonText: { color: Colors.surface, fontSize: 18, fontWeight: 'bold' },
-    manualCaptureButton: { backgroundColor: 'rgba(255,255,255,0.2)', paddingVertical: 12, paddingHorizontal: 32, borderRadius: 24, borderWidth: 1, borderColor: 'rgba(255,255,255,0.4)' },
+    manualCaptureButton: { backgroundColor: 'rgba(255,255,255,0.2)', paddingVertical: 12, paddingHorizontal: 32, borderRadius: 24, borderWidth: 1, borderColor: 'rgba(255,255,255,0.4)', marginTop: 8 },
     manualCaptureText: { color: 'white', fontSize: 15, fontWeight: '600' },
-=======
-    statusBox: { backgroundColor: 'rgba(0,0,0,0.7)', paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 16 },
-    statusBoxWarning: { backgroundColor: Colors.warning[500], paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 16 },
-    errorBox: { backgroundColor: Colors.error[500], paddingHorizontal: 24, paddingVertical: 12, borderRadius: 24, marginBottom: 16 },
-    statusText: { color: 'white', fontSize: 18, fontWeight: 'bold' },
-    statusTextWarning: { color: Colors.surface, fontSize: 16, fontWeight: 'bold' },
-    errorText: { color: 'white', fontSize: 18, fontWeight: 'bold', textAlign: 'center' },
-    statusSuccess: { color: Colors.success[500] },
-    saveButton: { backgroundColor: Colors.primary[500], paddingVertical: 18, paddingHorizontal: 48, borderRadius: 32, width: '100%', alignItems: 'center' },
-    saveButtonText: { color: Colors.surface, fontSize: 18, fontWeight: 'bold' },
->>>>>>> 2e97166a1805b34dad49b1a89250fc6ddcb52e8c
     confirmationBox: { backgroundColor: 'rgba(255,255,255,0.95)', padding: 24, borderRadius: 24, width: '100%', alignItems: 'center' },
     confirmationTitle: { fontSize: 24, fontWeight: 'bold', color: Colors.primary[900], marginBottom: 8 },
     confirmationSubtitle: { fontSize: 16, color: Colors.primary[700], marginBottom: 24, textAlign: 'center' },
